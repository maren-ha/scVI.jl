<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Data processing · scVI</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.svg" alt="scVI logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">scVI</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Getting started</a></li><li class="is-active"><a class="tocitem" href="DataProcessing.html">Data processing</a><ul class="internal"><li><a class="tocitem" href="#AnnData-object"><span><code>AnnData</code> object</span></a></li><li><a class="tocitem" href="#I/O"><span>I/O</span></a></li><li><a class="tocitem" href="#Library-size-and-normalization"><span>Library size and normalization</span></a></li><li><a class="tocitem" href="#Filtering"><span>Filtering</span></a></li><li><a class="tocitem" href="#Simple-transformations"><span>Simple transformations</span></a></li><li><a class="tocitem" href="#Dimension-reduction"><span>Dimension reduction</span></a></li><li><a class="tocitem" href="#Highly-variable-genes"><span>Highly variable genes</span></a></li><li><a class="tocitem" href="#Loading-built-in-datasets"><span>Loading built-in datasets</span></a></li></ul></li><li><a class="tocitem" href="scVAE.html">The scVAE model</a></li><li><a class="tocitem" href="scLDVAE.html">The scLDVAE model</a></li><li><a class="tocitem" href="Training.html">Model training</a></li><li><a class="tocitem" href="Evaluation.html">Model evaluation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="DataProcessing.html">Data processing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="DataProcessing.html">Data processing</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/maren-ha/scVI.jl/blob/origin/main/docs/src/DataProcessing.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-processing"><a class="docs-heading-anchor" href="#Data-processing">Data processing</a><a id="Data-processing-1"></a><a class="docs-heading-anchor-permalink" href="#Data-processing" title="Permalink"></a></h1><h2 id="AnnData-object"><a class="docs-heading-anchor" href="#AnnData-object"><code>AnnData</code> object</a><a id="AnnData-object-1"></a><a class="docs-heading-anchor-permalink" href="#AnnData-object" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="scVI.AnnData" href="#scVI.AnnData"><code>scVI.AnnData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct AnnData</code></pre><p>Minimal Julia implementation of the Python <code>AnnData</code> object (see <a href="https://anndata.readthedocs.io/en/latest/">package documentation</a> and <a href="https://github.com/scverse/anndata">Github repository</a>): An <code>AnnData</code> object stores a <code>countmatrix</code> together with annotations  of observations <code>obs</code> (<code>obsm</code>, <code>obsp</code>), variables <code>var</code> (<code>varm</code>, <code>varp</code>), and unstructured annotations <code>uns</code>.</p><p><strong><strong>Keyword arguments</strong></strong></p><ul><li><code>countmatrix::Matrix</code>: countmatrix in (cell x gene) shape</li><li><code>layers::Union{Dict,Nothing}=nothing</code>: dictionary of other layers (e.g., normalized counts) in the same shape as the countmatrix</li><li><code>obs::Union{DataFrame,Nothing}=nothing</code>: dataframe of information about cells, e.g., celltypes</li><li><code>obsm::Union{Dict, Nothing}=nothing</code>: dictionary of observation-level matrices, e.g., a UMAP embedding. The first dimension of the matrix has to correspond to the number of cells.</li><li><code>obsp::Union{Dict, Nothing}=nothing</code>: dictionary of (observation x observation) matrices, e.g., representing cell graphs. </li><li><code>var::Union{DataFrame, Nothing}=nothing</code>: dataframe of information about genes/features, e.g., gene names or highly variable genes</li><li><code>varm::Union{DataFrame, Nothing}=nothing</code>: dictionary of variable-level matrices. The first dimension of the matrix has to correspond to the number of genes.</li><li><code>obsp::Union{Dict, Nothing}=nothing</code>: dictionary of (variable x variable) matrices, e.g., representing gene graphs. </li><li><code>celltypes=nothing</code>: vector of cell type names, shorthand for <code>adata.obs[&quot;cell_type&quot;]</code></li><li><code>uns::Union{Dict, Nothing}=nothing</code>: dictionary of unstructured annotation. </li></ul><p><strong><strong>Example</strong></strong></p><pre><code class="nohighlight hljs">julia&gt; adata = load_tasic(&quot;scvi/data/&quot;)
    AnnData object with a countmatrix with 1679 cells and 15119 genes
        layers dict with the following keys: [&quot;normalized_counts&quot;, &quot;counts&quot;]
        unique celltypes: [&quot;Vip&quot;, &quot;L4&quot;, &quot;L2/3&quot;, &quot;L2&quot;, &quot;Pvalb&quot;, &quot;Ndnf&quot;, &quot;L5a&quot;, &quot;SMC&quot;, &quot;Astro&quot;, &quot;L5&quot;, &quot;Micro&quot;, &quot;Endo&quot;, &quot;Sst&quot;, &quot;L6b&quot;, &quot;Sncg&quot;, &quot;Igtp&quot;, &quot;Oligo&quot;, &quot;Smad3&quot;, &quot;OPC&quot;, &quot;L5b&quot;, &quot;L6a&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/AnnData.jl#L4-L30">source</a></section></article><h2 id="I/O"><a class="docs-heading-anchor" href="#I/O">I/O</a><a id="I/O-1"></a><a class="docs-heading-anchor-permalink" href="#I/O" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="scVI.read_h5ad" href="#scVI.read_h5ad"><code>scVI.read_h5ad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_h5ad(filename::String)</code></pre><p>Reads an h5ad file from the given <code>filename</code>, and returns an AnnData object containing the cell-gene expression matrix and other relevant information  stored in the h5ad file.</p><p><strong>Arguments</strong></p><ul><li><code>filename::String</code>: Path to the h5ad file.</li></ul><p><strong>Returns</strong></p><ul><li><code>adata</code>: An AnnData object containing the following data fields populated </li></ul><p>from the h5ad file:     - <code>countmatrix</code>: The cell-gene expression matrix.     - <code>layers</code>, <code>obsm</code>, <code>obsp</code>, <code>varm</code>, <code>varp</code>, and <code>uns</code>: Dictionary fields.     - <code>obs</code> and <code>var</code>: DataFrame fields.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; adata = read_h5ad(&quot;mydata.h5ad&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/FileIO.jl#L49-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="scVI.write_h5ad" href="#scVI.write_h5ad"><code>scVI.write_h5ad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">write_h5ad(adata::AnnData, filename::String)</code></pre><p>Write an AnnData object to an H5AD file.</p><p><strong>Arguments</strong></p><ul><li><code>adata::AnnData</code>: The AnnData object to write to the H5AD file.</li><li><code>filename::String</code>: The path to the H5AD file to write.</li></ul><p><strong>Returns</strong></p><ul><li>Nothing.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">adata = read_h5ad(&quot;example.h5ad&quot;)
write_h5ad(adata, &quot;output.h5&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/FileIO.jl#L127-L144">source</a></section></article><h2 id="Library-size-and-normalization"><a class="docs-heading-anchor" href="#Library-size-and-normalization">Library size and normalization</a><a id="Library-size-and-normalization-1"></a><a class="docs-heading-anchor-permalink" href="#Library-size-and-normalization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="scVI.init_library_size" href="#scVI.init_library_size"><code>scVI.init_library_size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">init_library_size(adata::AnnData; batch_key::Symbol=:batch)</code></pre><p>Computes and returns library size based on <code>AnnData</code> object. </p><p>Based on the <code>scvi-tools</code> function from <a href="https://github.com/scverse/scvi-tools/blob/04389f74f3e94d7d2986f93eac85cb4543a8608f/scvi/model/_utils.py#L229">here</a> </p><p>Returns a tupe of arrays of length equal to the number of batches in <code>adata</code> as stored in <code>adata.obs[!,:batch_key]</code>,  containing the means and variances of the library size in each batch in <code>adata</code>. Default batch key: <code>:batch</code>, if it is not found, defaults to 1 batch.     </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/LibrarySizeNormalization.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="scVI.estimate_size_factors" href="#scVI.estimate_size_factors"><code>scVI.estimate_size_factors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">estimate_size_factors(mat; locfunc=median)</code></pre><p>Estimates size factors to use for normalization, based on the corresponding Seurat functionality.  Assumes a countmatrix <code>mat</code> in cell x gene format as input, returns a vector of size factors. </p><p>For details, please see the Seurat documentation. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/LibrarySizeNormalization.jl#L43-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="scVI.normalize_size_factors" href="#scVI.normalize_size_factors"><code>scVI.normalize_size_factors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize_size_factors(mat::Abstractmatrix)</code></pre><p>Normalizes the countdata in <code>mat</code> by dividing it by the size factors calculated with <code>estimate_size_factors</code>.  Assumes a countmatrix <code>mat</code> in cell x gene format as input, returns the normalized matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/LibrarySizeNormalization.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="scVI.normalize_size_factors!" href="#scVI.normalize_size_factors!"><code>scVI.normalize_size_factors!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize_size_factors(adata::AnnData)</code></pre><p>Normalizes the <code>adata.countmatrix</code> by dividing it by the size factors calculated with <code>estimate_size_factors</code>.  Adds the normalized count matrix to <code>adata.layers</code> and returns <code>adata</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/LibrarySizeNormalization.jl#L76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="scVI.normalize_total!" href="#scVI.normalize_total!"><code>scVI.normalize_total!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize_total!(adata::AnnData; 
    target_sum::Union{Nothing, Real}=nothing, 
    key_added::String=&quot;cell_counts&quot;,
    layer::Union{Nothing, String}=nothing,
    verbose::Bool=false)</code></pre><p>Normalizes counts per cell, specifically normalize each cell by total counts over all genes, so that every cell has the same total count after normalization. If choosing <code>target_sum=1e6</code>, this is CPM normalization.</p><p>Basic version of the <a href="https://github.com/scverse/scanpy/blob/ed3b277b2f498e3cab04c9416aaddf97eec8c3e2/scanpy/preprocessing/_normalization.py#L45-L241">scanpy.pp.normalize_total function</a></p><p><strong><strong>Arguments</strong></strong></p><ul><li><code>adata</code>: <code>AnnData</code> object </li><li><code>target_sum</code>: if <code>nothing</code>, after normalization, each observation (cell) has a total count equal to the median of total counts for observations (cells) before normalization.</li><li><code>key_added</code>: name of the field in <code>adata.obs</code> where the normalization factor is stored, set to &quot;cell_counts&quot; by default </li><li><code>layer</code>: optional; which layer to normalize on. If <code>nothing</code>, <code>adata.countmatrix</code> is used. </li></ul><p><strong><strong>Returns</strong></strong></p><p>Returns <code>adata</code> with normalized version of the original <code>adata.X</code> in <code>adata.layers</code> and the size factors in <code>adata.obs</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/LibrarySizeNormalization.jl#L92-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="scVI.normalize_total" href="#scVI.normalize_total"><code>scVI.normalize_total</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize_total(adata::AnnData; 
    target_sum::Union{Nothing, Real}=1e4, 
    key_added::String=&quot;cell_counts&quot;,
    verbose::Bool=false)</code></pre><p>Normalizes counts per cell, specifically normalize each cell by total counts over all genes, so that every cell has the same total count after normalization. See <code>normalize_total!</code> for details.  Unlike the in-place version, this function returns a dictionary with the normalized counts and scaled counts per cell. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/LibrarySizeNormalization.jl#L133-L142">source</a></section></article><h2 id="Filtering"><a class="docs-heading-anchor" href="#Filtering">Filtering</a><a id="Filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="scVI.filter_cells" href="#scVI.filter_cells"><code>scVI.filter_cells</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function filter_cells(adata::AnnData; 
    min_counts::Union{Int, Nothing}=nothing, 
    min_genes::Union{Int, Nothing}=nothing, 
    max_counts::Union{Int, Nothing}=nothing, 
    max_genes::Union{Int, Nothing}=nothing,
    verbose::Bool = true)</code></pre><p>Filter cell outliers based on counts and numbers of genes expressed. For instance, only keep cells with at least <code>min_counts</code> counts or <code>min_genes</code> genes expressed. This is to filter measurement outliers, i.e. “unreliable” observations. Only provide one of the optional parameters <code>min_counts</code>, <code>min_genes</code>, <code>max_counts</code>, <code>max_genes</code> per call.</p><p><strong>Parameters</strong></p><ul><li><code>adata</code>: <code>AnnData</code> object of shape <code>n_obs</code> × <code>n_vars</code>. Rows correspond to cells and columns to genes.</li><li><code>min_counts</code>: Minimum number of counts required for a cell to pass filtering.</li><li><code>min_genes</code>: Minimum number of genes expressed required for a cell to pass filtering.</li><li><code>max_counts</code>: Maximum number of counts required for a cell to pass filtering.</li><li><code>max_genes</code>: Maximum number of genes expressed required for a cell to pass filtering.</li></ul><p><strong>Returns</strong></p><ul><li><code>cells_subset</code>: BitVector index mask that does filtering; <code>true</code> means that the      cell is kept, <code>false</code> means the cell is removed.</li><li><code>number_per_cell</code>      Depending on what was thresholded (<code>counts</code> or <code>genes</code>),      the array stores <code>n_counts</code> or <code>n_cells</code> per gene.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/Filtering.jl#L57-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="scVI.filter_cells!" href="#scVI.filter_cells!"><code>scVI.filter_cells!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function filter_cells!(adata::AnnData; 
    min_counts::Union{Int, Nothing}=nothing, 
    min_genes::Union{Int, Nothing}=nothing, 
    max_counts::Union{Int, Nothing}=nothing, 
    max_genes::Union{Int, Nothing}=nothing,
    verbose::Bool = true)</code></pre><p>Filter cell outliers based on counts and numbers of genes expressed. For instance, only keep cells with at least <code>min_counts</code> counts or <code>min_genes</code> genes expressed. This is to filter measurement outliers, i.e. “unreliable” observations. Only provide one of the optional parameters <code>min_counts</code>, <code>min_genes</code>, <code>max_counts</code>, <code>max_genes</code> per call.</p><p><strong>Parameters</strong></p><ul><li><code>adata</code>: <code>AnnData</code> object of shape <code>n_obs</code> × <code>n_vars</code>. Rows correspond to cells and columns to genes.</li><li><code>min_counts</code>: Minimum number of counts required for a cell to pass filtering.</li><li><code>min_genes</code>: Minimum number of genes expressed required for a cell to pass filtering.</li><li><code>max_counts</code>: Maximum number of counts required for a cell to pass filtering.</li><li><code>max_genes</code>: Maximum number of genes expressed required for a cell to pass filtering.</li></ul><p><strong>Returns</strong></p><p>The filtered <code>AnnData</code> object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/Filtering.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="scVI.filter_genes!" href="#scVI.filter_genes!"><code>scVI.filter_genes!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">filter_genes!(adata::AnnData; 
    min_counts::Union{Int, Nothing}=nothing, 
    min_cells::Union{Int, Nothing}=nothing, 
    max_counts::Union{Int, Nothing}=nothing, 
    max_cells::Union{Int, Nothing}=nothing,
    verbose::Bool = true)</code></pre><p>Filter genes based on number of cells or counts. Keep genes that have at least <code>min_counts</code> counts or are expressed in at least <code>min_cells</code> cells or have at most <code>max_counts</code> counts or are expressed in at most <code>max_cells</code> cells. Only provide one of the optional parameters <code>min_counts</code>, <code>min_cells</code>, <code>max_counts</code>, <code>max_cells</code> per call.</p><p><strong>Parameters</strong></p><ul><li><code>adata</code>: <code>AnnData</code> object of shape <code>n_obs</code> × <code>n_vars</code>. Rows correspond  to cells and columns to genes.</li><li><code>min_counts</code>: Minimum number of counts required for a gene to pass filtering.</li><li><code>min_cells</code>: Minimum number of cells expressed required for a gene to pass filtering.</li><li><code>max_counts</code>: Maximum number of counts required for a gene to pass filtering.</li><li><code>max_cells</code>: Maximum number of cells expressed required for a gene to pass filtering.</li></ul><p><strong>Returns</strong></p><p>The filtered <code>AnnData</code> object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/Filtering.jl#L151-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="scVI.filter_genes" href="#scVI.filter_genes"><code>scVI.filter_genes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">filter_genes(adata::AnnData; 
    min_counts::Union{Int, Nothing}=nothing, 
    min_cells::Union{Int, Nothing}=nothing, 
    max_counts::Union{Int, Nothing}=nothing, 
    max_cells::Union{Int, Nothing}=nothing,
    verbose::Bool = true)</code></pre><p>Filter genes based on number of cells or counts. Keep genes that have at least <code>min_counts</code> counts or are expressed in at least <code>min_cells</code> cells or have at most <code>max_counts</code> counts or are expressed in at most <code>max_cells</code> cells. Only provide one of the optional parameters <code>min_counts</code>, <code>min_cells</code>, <code>max_counts</code>, <code>max_cells</code> per call. This is the out-of-place version; for details on the input arguments, see the in-place version <code>filter_genes!</code></p><p><strong>Returns</strong></p><p>A <code>BitVector</code> with <code>true</code> for every gene that should be included  and a vector specifying for each gene the number of cells it is expressed in. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/Filtering.jl#L208-L228">source</a></section></article><h2 id="Simple-transformations"><a class="docs-heading-anchor" href="#Simple-transformations">Simple transformations</a><a id="Simple-transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-transformations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="scVI.log_transform!" href="#scVI.log_transform!"><code>scVI.log_transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">log_transform!(adata::AnnData; 
    layer::String=&quot;normalized&quot;,
    verbose::Bool=false)</code></pre><p>Log-transforms the data. Looks for a layer of normalized counts in <code>adata.layers[&quot;normalized&quot;]</code>.  If the layer is not there, it uses <code>adata.countmatrix</code>.  Returns the adata object with the log-transformed values in a new layer <code>&quot;log_transformed&quot;</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/Transformations.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="scVI.logp1_transform!" href="#scVI.logp1_transform!"><code>scVI.logp1_transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logp1_transform!(adata::AnnData; 
    layer::Union{String, Nothing}=nothing,
    verbose::Bool=false)</code></pre><p>Log-transforms the (count) data, adding a pseudocount of 1.  Uses the countmatrix in <code>adata.countmatrix</code> by default, but other layers can be passed using the <code>layer</code> keyword.  Returns the adata object with the log-transformed values in a new layer <code>&quot;logp1_transformed&quot;</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/Transformations.jl#L31-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="scVI.sqrt_transform!" href="#scVI.sqrt_transform!"><code>scVI.sqrt_transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sqrt_transform!(adata::AnnData; 
    layer::String=&quot;normalized&quot;,
    verbose::Bool=false)</code></pre><p>Sqrt-transforms the data. Looks for a layer of normalized counts in <code>adata.layers[&quot;normalized&quot;]</code>.  If the layer is not there, it uses <code>adata.countmatrix</code>.  Returns the adata object with the sqrt-transformed values in a new layer <code>&quot;sqrt_transformed&quot;</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/Transformations.jl#L63-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="scVI.rescale!" href="#scVI.rescale!"><code>scVI.rescale!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rescale!(adata::AnnData; 
    layer::Union{String, Nothing}=nothing,
    verbose::Bool=false)</code></pre><p>Rescales the data to zero mean and unit variance in each gene, using the specified layer. If none is provided, it uses <code>adata.countmatrix</code>.  Returns the adata object with the rescales values in a new layer <code>&quot;rescaled&quot;</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/Transformations.jl#L93-L100">source</a></section></article><h2 id="Dimension-reduction"><a class="docs-heading-anchor" href="#Dimension-reduction">Dimension reduction</a><a id="Dimension-reduction-1"></a><a class="docs-heading-anchor-permalink" href="#Dimension-reduction" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="scVI.pca!" href="#scVI.pca!"><code>scVI.pca!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function pca!(adata::AnnData; 
    layer::String=&quot;log_transformed&quot;, 
    n_pcs::Int=size(adata.countmatrix,2),
    verbose::Bool=false
)</code></pre><p>Performs a PCA on the specified layer of an <code>AnnData</code> object and stores the results in <code>adata.obsm</code>.  Uses all variables of the layer by default, but the number of PCs to be stored can also be specified with the <code>n_pcs</code> keyword.  Returns the modified <code>AnnData</code> object. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/DimensionReduction.jl#L15-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="scVI.umap!" href="#scVI.umap!"><code>scVI.umap!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function umap!(adata::AnnData; 
    layer::String=&quot;log_transformed&quot;, 
    use_pca_init::Bool=false, 
    n_pcs::Int=100, 
    verbose::Bool=true, 
    kwargs...)</code></pre><p>Performs UMAP on the specified layer of an <code>AnnData</code> object.  If the layer is not found, the log-transformed normalized counts are calculated and used.  Optionally, UMAP can be run on a PCA representation, the number of PCs can be specified (default=100).  For customizing the behaviour or UMAP, see the keyword arguments of the <code>UMAP.UMAP_</code> function.  They can all be passed via the <code>kwargs</code>. </p><p>The fields of the resulting <code>UMAP_</code> struct are stored as follows:      - the UMAP embedding in <code>adata.obsm[&quot;umap&quot;]</code>,      - the fuzzy simplicial knn graph in adata.obsp[&quot;fuzzy<em>neighbor</em>graph&quot;],      - the KNNs of each cell in <code>adata.obsm[&quot;knns&quot;]</code>,      - the distances of each cell to its KNNs in <code>adata.obsm[&quot;knn_dists&quot;]</code></p><p>Returns the modified AnnData object. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/DimensionReduction.jl#L72-L93">source</a></section></article><h2 id="Highly-variable-genes"><a class="docs-heading-anchor" href="#Highly-variable-genes">Highly variable genes</a><a id="Highly-variable-genes-1"></a><a class="docs-heading-anchor-permalink" href="#Highly-variable-genes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="scVI.highly_variable_genes-Tuple{AnnData}" href="#scVI.highly_variable_genes-Tuple{AnnData}"><code>scVI.highly_variable_genes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">highly_variable_genes(adata::AnnData;
    layer::Union{String,Nothing} = nothing,
    n_top_genes::Int=2000,
    batch_key::Union{String,Nothing} = nothing,
    span::Float64=0.3
    )</code></pre><p>Computes highly variable genes according to the workflows on <code>scanpy</code> and Seurat v3 per batch and returns a dictionary with  the information on the joint HVGs. For the in-place version, see <code>highly_variable_genes!</code></p><p>More specifically, it is the Julia re-implementation of the corresponding  <a href="https://github.com/scverse/scanpy/blob/master/scanpy/preprocessing/_highly_variable_genes.py"><code>scanpy</code> function</a> For implementation details, please check the <code>scanpy</code>/Seurat documentations or the source code of the  lower-level <code>_highly_variable_genes_seurat_v3</code> function in this package.  Results are almost identical to the <code>scanpy</code> function. The differences have been traced back to differences in  the local regression for the mean-variance relationship implemented in the Loess.jl package, that differs slightly  from the corresponding Python implementation. </p><p><strong><strong>Arguments</strong></strong></p><ul><li><code>adata</code>: <code>AnnData</code> object </li><li><code>layer</code>: optional; which layer to use for calculating the HVGs. Function assumes this is a layer of counts. If <code>layer</code> is not provided, <code>adata.countmatrix</code> is used. </li><li><code>n_top_genes</code>: optional; desired number of highly variable genes. Default: 2000. </li><li><code>batch_key</code>: optional; key where to look for the batch indices in <code>adata.obs</code>. If not provided, data is treated as one batch. </li><li><code>span</code>: span to use in the loess fit for the mean-variance local regression. See the Loess.jl docs for details. </li><li><code>replace_hvgs</code>: whether or not to replace the hvg information if there are already hvgs calculated. If false, the new values are added with a &quot;_1&quot; suffix. Default:true,</li><li><code>verbose</code>: whether or not to print info on current status</li></ul><p><strong><strong>Returns</strong></strong></p><p>Returns a dictionary containing information on the highly variable genes, specifically containing the following keys is added: </p><ul><li><code>highly_variable</code>: vector of <code>Bool</code>s indicating which genes are highly variable</li><li><code>highly_variable_rank</code>: rank of the highly variable genes according to (corrected) variance </li><li><code>means</code>: vector with means of each gene</li><li><code>variances</code>: vector with variances of each gene </li><li><code>variances_norm</code>: normalized variances of each gene </li><li><code>highly_variable_nbatches</code>: if there are batches in the dataset, logs the number of batches in which each highly variable gene was actually detected as highly variable. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/HighlyVariableGenes.jl#L152-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="scVI.highly_variable_genes!-Tuple{AnnData}" href="#scVI.highly_variable_genes!-Tuple{AnnData}"><code>scVI.highly_variable_genes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">highly_variable_genes!(adata::AnnData;
    layer::Union{String,Nothing} = nothing,
    n_top_genes::Int=2000,
    batch_key::Union{String,Nothing} = nothing,
    span::Float64=0.3,
    replace_hvgs::Bool=true,
    verbose::Bool=false
    )</code></pre><p>Computes highly variable genes per batch according to the workflows on <code>scanpy</code> and Seurat v3 in-place.  This is the in-place version that adds an dictionary containing information on the highly variable genes directly  to the <code>adata.var</code> and returns the modified <code>AnnData</code> object.  For details, see the not-in-place version <code>?highly_variable_genes</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/HighlyVariableGenes.jl#L118-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="scVI.subset_to_hvg!-Tuple{AnnData}" href="#scVI.subset_to_hvg!-Tuple{AnnData}"><code>scVI.subset_to_hvg!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subset_to_hvg!(adata::AnnData;
    layer::Union{String,Nothing} = nothing,
    n_top_genes::Int=2000,
    batch_key::Union{String,Nothing} = nothing,
    span::Float64=0.3,
    verbose::Bool=true
)</code></pre><p>Calculates highly variable genes with <code>highly_variable_genes!</code> and subsets the <code>AnnData</code> object to the calculated HVGs.  For description of input arguments, see <code>highly_variable_genes!</code></p><p>Returns: <code>adata</code> object subset to the calculated HVGs, both in the countmatrix/layer data used for HVG calculation and in the <code>adata.var</code> dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/HighlyVariableGenes.jl#L210-L223">source</a></section></article><h2 id="Loading-built-in-datasets"><a class="docs-heading-anchor" href="#Loading-built-in-datasets">Loading built-in datasets</a><a id="Loading-built-in-datasets-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-built-in-datasets" title="Permalink"></a></h2><p>There are currently three datasets for which the package supplies built-in convenience functions for loading, processing and creating corresponding <code>AnnData</code> objects. They can be downloaded from this <a href="https://drive.google.com/drive/folders/1JYNypxWnQhigEJ37jOiEwv7fzGW71jC8?usp=sharing">Google Drive <code>data</code> folder</a>. The folder contains all three datasets, namely </p><ul><li>the <code>cortex</code> data, corresponding to the <a href="https://github.com/scverse/scvi-tools/blob/master/scvi/data/_built_in_data/_cortex.py"><code>cortex</code> dataset from the <code>scvi-tools</code></a> from <a href="https://www.science.org/doi/10.1126/science.aaa1934">Zeisel et al. 2015</a>. The original data can be found <a href="https://storage.googleapis.com/linnarsson-lab-www-blobs/blobs/cortex/expression_mRNA_17-Aug-2014.txt">here</a> and has been processed analogous to the <a href="https://github.com/scverse/scvi-tools/blob/master/scvi/data/_built_in_data/_cortex.py"><code>scvi-tools</code> processing</a></li><li>the <code>tasic</code> data from <a href="https://www.nature.com/articles/nn.4216">Tasic et al. (2016)</a>, available at <a href="https://www.ncbi.nlm.nih.gov/geo/">Gene expression Omnibus (GEO)</a> under accession number GSE71585. Preprocessing and additional annotation according to the original manuscript; annotations are available and loaded together with the countmatrix. </li><li>the <code>pbmc</code> data (PBMC8k) from <a href="https://www.nature.com/articles/ncomms14049">Zheng et al. 2017</a>, preprocessed according to the <a href="https://bioconductor.org/books/3.15/OSCA.workflows/unfiltered-human-pbmcs-10x-genomics.html">Bioconductor workflow</a>.</li></ul><p>I recommend downloading the complete GoogleDrive folder and having it as a subfolder named <code>data</code> in the current working directory. Then, in any Julia script in the parent directory, the functions <code>load_cortex()</code>, <code>load_pbmc()</code> and <code>load_tasic()</code> can be called without arguments, because the default <code>path</code> where these functions look for the respective dataset is exactly that subfolder named <code>data</code>.  </p><h3 id="Cortex-data"><a class="docs-heading-anchor" href="#Cortex-data">Cortex data</a><a id="Cortex-data-1"></a><a class="docs-heading-anchor-permalink" href="#Cortex-data" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="scVI.load_cortex_from_h5ad" href="#scVI.load_cortex_from_h5ad"><code>scVI.load_cortex_from_h5ad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_cortex_from_h5ad(filename::String=&quot;cortex_anndata.h5ad&quot;)</code></pre><p>Reads cortex data from an <code>anndata</code> object created and used with the Python scVI and saved as H5AD file, based on the <code>read_h5ad</code> function. </p><p>Extracts information to populate a corresponding Julia <code>AnnData</code> object and returns it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/Cortex.jl#L6-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="scVI.load_cortex" href="#scVI.load_cortex"><code>scVI.load_cortex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_cortex(path::String=&quot;&quot;; verbose::Bool=false)</code></pre><p>Loads <code>cortex</code> dataset from <a href="https://www.science.org/doi/10.1126/science.aaa1934">Zeisel et al. 2015</a> and creates a corresponding <code>AnnData</code> object. </p><p>Looks for a file <code>cortex_anndata.h5ad</code> that can be downloaded from <a href="https://drive.google.com/drive/folders/1JYNypxWnQhigEJ37jOiEwv7fzGW71jC8?usp=sharing">this GoogleDrive <code>data</code> folder</a>.  The functions first looks in the folder passed as <code>path</code> (default: assumes files are in a subfolder named <code>data</code> of the current directory, i.e., that the complete GoogleDrive <code>data</code> folder has been downloaded in the current directory), and alternatively downloads the data if is cannot find the file in the given <code>path</code> (see below).</p><p>The file is the <code>h5</code> export of the Python <code>AnnData</code> object provided as <a href="https://github.com/scverse/scvi-tools/blob/master/scvi/data/_built_in_data/_cortex.py">built-in <code>cortex</code> dataset from <code>scvi-tools</code></a>,  data is from <a href="https://www.science.org/doi/10.1126/science.aaa1934">Zeisel et al. 2015</a>.</p><p>If the file is present, the data is loaded from the Python <code>AnnData</code> object and stored in an analogous Julia <code>AnnData</code> object.  This is handled by the functions <code>init_cortex_from_h5ad</code> and <code>load_cortex_from_h5ad</code>. </p><p>Alternatively, if the <code>h5ad</code> file is not found in the folder, the data is downloaded directly  <a href="https://storage.googleapis.com/linnarsson-lab-www-blobs/blobs/cortex/expression_mRNA_17-Aug-2014.txt">from the original authors</a> and  processed analogous to the <a href="https://github.com/scverse/scvi-tools/blob/master/scvi/data/_built_in_data/_cortex.py"><code>scvi-tools</code> processing</a>,  and subsequently stored to a Julia <code>AnnData</code> object. This is handled by the function <code>init_cortex_from_url</code>. </p><p>Returns the Julia <code>AnnData</code> object.</p><p><strong><strong>Example</strong></strong></p><pre><code class="nohighlight hljs">julia&gt; load_cortex()
    AnnData object with a countmatrix with 3005 cells and 1200 genes
    layers dict with the following keys: [&quot;counts&quot;]
    summary statistics dict with the following keys: [&quot;n_labels&quot;, &quot;n_vars&quot;, &quot;n_batch&quot;, &quot;n_continuous_covs&quot;, &quot;n_cells&quot;, &quot;n_proteins&quot;]
    unique celltypes: [&quot;interneurons&quot;, &quot;pyramidal SS&quot;, &quot;pyramidal CA1&quot;, &quot;oligodendrocytes&quot;, &quot;microglia&quot;, &quot;endothelial-mural&quot;, &quot;astrocytes_ependymal&quot;]
    training status: not trained</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/Cortex.jl#L78-L108">source</a></section></article><h3 id="PBMC-data"><a class="docs-heading-anchor" href="#PBMC-data">PBMC data</a><a id="PBMC-data-1"></a><a class="docs-heading-anchor-permalink" href="#PBMC-data" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="scVI.load_pbmc" href="#scVI.load_pbmc"><code>scVI.load_pbmc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_pbmc(path::String = &quot;data/&quot;)</code></pre><p>Loads <code>pbmc</code> dataset from <a href="https://www.nature.com/articles/ncomms14049">Zheng et al. 2017</a> and creates a corresponding <code>AnnData</code> object.  Specifically, the PBMC8k version is used, preprocessed according to the <a href="https://bioconductor.org/books/3.15/OSCA.workflows/unfiltered-human-pbmcs-10x-genomics.html">Bioconductor workflow</a>.</p><p>Loads the following files that can be downloaded from <a href="https://drive.google.com/drive/folders/1JYNypxWnQhigEJ37jOiEwv7fzGW71jC8?usp=sharing">this GoogleDrive <code>data</code> folder</a>: </p><ul><li><code>PBMC_counts.csv</code>: countmatrix  </li><li><code>PBMC_annotation.csv</code>: cell type annotation</li></ul><p>Files are loaded from the folder passed as <code>path</code> (default: assumes files are in a subfolder named <code>data</code> of the current directory, i.e., that the complete GoogleDrive <code>data</code> folder has been downloaded in the current directory.)</p><p>From these input files, a Julia <code>AnnData</code> object is created. The countmatrix contains information on  cell barcodes and gene names. The gene name and celltype information is stored in the <code>vars</code> and <code>obs</code>  dictionaries of the <code>AnnData</code> object, respectively. </p><p>Returns the Julia <code>AnnData</code> object.</p><p><strong><strong>Example</strong></strong></p><pre><code class="nohighlight hljs">julia&gt; load_pbmc()
    AnnData object with a countmatrix with 7480 cells and 200 genes
    unique celltypes: [&quot;B-cells&quot;, &quot;CD4+ T-cells&quot;, &quot;Monocytes&quot;, &quot;CD8+ T-cells&quot;, &quot;NK cells&quot;, &quot;NA&quot;, &quot;HSC&quot;, &quot;Erythrocytes&quot;]
    training status: not trained</code></pre><p><strong></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/PBMC.jl#L4-L30">source</a></section></article><h3 id="Tasic-data"><a class="docs-heading-anchor" href="#Tasic-data">Tasic data</a><a id="Tasic-data-1"></a><a class="docs-heading-anchor-permalink" href="#Tasic-data" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="scVI.load_tasic" href="#scVI.load_tasic"><code>scVI.load_tasic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_tasic(path::String = &quot;data/&quot;)</code></pre><p>Loads <code>tasic</code> dataset based on <a href="https://www.nature.com/articles/nn.4216">Tasic et al. (2016)</a> and creates a corresponding <code>AnnData</code> object. </p><p>Loads the following files that can be downloaded from <a href="https://drive.google.com/drive/folders/1JYNypxWnQhigEJ37jOiEwv7fzGW71jC8?usp=sharing">this GoogleDrive <code>data</code> folder</a>: </p><ul><li><code>Tasic_countmat.txt</code>: countmatrix  </li><li><code>Tasic_celltypes.txt</code>: cell types</li><li><code>Tasic_genenames.txt</code>: gene names </li><li><code>Tasic_receptorandmarkers.txt</code>: List of receptor and marker genes </li></ul><p>Files are loaded from the folder passed as <code>path</code> (default: assumes files are in a subfolder named <code>data</code> of the current directory, i.e., that the complete GoogleDrive <code>data</code> folder has been downloaded in the current directory.</p><p>The original data is available at <a href="https://www.ncbi.nlm.nih.gov/geo/">Gene expression Omnibus (GEO)</a> under accession number GSE71585.  Preprocessing and annotation has been prepared according to the original manuscript. </p><p>From these input files, a Julia <code>AnnData</code> object is created. The list of receptor and marker genes is used  to annotate cells as neural vs. non-neural, and annotate the neural cells as  GABA- or Glutamatergic. </p><p>These annotations together with the cell type information and the gene names and receptor/marker list are stored in Dictionaries  in the <code>obs</code> and <code>vars</code> fields of the <code>AnnData</code> obejct. </p><p>Additionally, size factors are calculated and used for normalizing the counts.  The normalized counts are stored in an additional <code>layer</code> named <code>normalized_counts</code>.</p><p>Returns the Julia <code>AnnData</code> object.</p><p><strong><strong>Example</strong></strong></p><pre><code class="nohighlight hljs">julia&gt; load_tasic()
    AnnData object with a countmatrix with 1679 cells and 15119 genes
    layers dict with the following keys: [&quot;normalized_counts&quot;, &quot;counts&quot;]
    unique celltypes: [&quot;Vip&quot;, &quot;L4&quot;, &quot;L2/3&quot;, &quot;L2&quot;, &quot;Pvalb&quot;, &quot;Ndnf&quot;, &quot;L5a&quot;, &quot;SMC&quot;, &quot;Astro&quot;, &quot;L5&quot;, &quot;Micro&quot;, &quot;Endo&quot;, &quot;Sst&quot;, &quot;L6b&quot;, &quot;Sncg&quot;, &quot;Igtp&quot;, &quot;Oligo&quot;, &quot;Smad3&quot;, &quot;OPC&quot;, &quot;L5b&quot;, &quot;L6a&quot;]
    training status: not trained</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/Tasic.jl#L5-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="scVI.subset_tasic!" href="#scVI.subset_tasic!"><code>scVI.subset_tasic!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">subset_tasic!(adata::AnnData)</code></pre><p>Subsets an input <code>AnnData</code> object initialized from the Tasic data according <code>load_tasic</code> to the neural cells  and the receptor and marker genes provided as annotation. </p><p>Specifically, the count matrix and the normalized count matrix are subset to these cells and genes,  and the dictionaries with information about cells and genes in <code>adata.obs</code> and <code>adata.vars</code> are also subset accordingly. </p><p>Returns the modified <code>AnnData</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/15cc52e7c1005447564257b4a6dab43cdfb655c2/src/data/Tasic.jl#L108-L118">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Getting started</a><a class="docs-footer-nextpage" href="scVAE.html">The scVAE model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 15 March 2023 13:22">Wednesday 15 March 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
