<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Data processing · scVI</title><meta name="title" content="Data processing · scVI"/><meta property="og:title" content="Data processing · scVI"/><meta property="twitter:title" content="Data processing · scVI"/><meta name="description" content="Documentation for scVI."/><meta property="og:description" content="Documentation for scVI."/><meta property="twitter:description" content="Documentation for scVI."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.svg" alt="scVI logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">scVI</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Getting started</a></li><li class="is-active"><a class="tocitem" href="DataProcessing.html">Data processing</a><ul class="internal"><li><a class="tocitem" href="#AnnData-object-and-I/O"><span><code>AnnData</code> object and I/O</span></a></li><li><a class="tocitem" href="#Library-size-and-normalization"><span>Library size and normalization</span></a></li><li><a class="tocitem" href="#Filtering"><span>Filtering</span></a></li><li><a class="tocitem" href="#Simple-transformations"><span>Simple transformations</span></a></li><li><a class="tocitem" href="#Dimension-reduction"><span>Dimension reduction</span></a></li><li><a class="tocitem" href="#Highly-variable-genes"><span>Highly variable genes</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#Loading-built-in-datasets"><span>Loading built-in datasets</span></a></li></ul></li><li><a class="tocitem" href="scVAE.html">The scVAE model</a></li><li><a class="tocitem" href="scLDVAE.html">The scLDVAE model</a></li><li><a class="tocitem" href="Training.html">Model training</a></li><li><a class="tocitem" href="Evaluation.html">Model evaluation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="DataProcessing.html">Data processing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="DataProcessing.html">Data processing</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/maren-ha/scVI.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/maren-ha/scVI.jl/blob/origin/main/docs/src/DataProcessing.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-processing"><a class="docs-heading-anchor" href="#Data-processing">Data processing</a><a id="Data-processing-1"></a><a class="docs-heading-anchor-permalink" href="#Data-processing" title="Permalink"></a></h1><h2 id="AnnData-object-and-I/O"><a class="docs-heading-anchor" href="#AnnData-object-and-I/O"><code>AnnData</code> object and I/O</a><a id="AnnData-object-and-I/O-1"></a><a class="docs-heading-anchor-permalink" href="#AnnData-object-and-I/O" title="Permalink"></a></h2><p>The <code>AnnData</code> struct is imported from <a href="https://github.com/scverse/Muon.jl"><code>Muon.jl</code></a>. The package provides read and write functions for <code>.h5ad</code> and <code>.h5mu</code> files, the typical H5-based format for storing Python <code>anndata</code> objects. The <code>AnnData</code> object stores datasets together with metadata, such as information on the variables (genes in scRNA-seq data) and observations (cells), as well as different kinds of annotations and transformations of the original count matrix, such as PCA or UMAP embeddings, or graphs of observations or variables. </p><p>For details on the Julia implementation in <code>Muon.jl</code>, see the <a href="https://scverse.github.io/Muon.jl/dev/">documentation</a>.</p><p>For more details on the original Python implementation of the <code>anndata</code> object, see the <a href="https://anndata.readthedocs.io/en/latest/">documentation</a> and <a href="https://doi.org/10.1101/2021.12.16.473007">preprint</a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.get_celltypes" href="#scVI.get_celltypes"><code>scVI.get_celltypes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_celltypes(a::AnnData)</code></pre><p>Tries to infer the cell types of cells in an <code>AnnData</code> object. </p><p>Returns a vector of cell type names if the cell types are stored in  <code>adata.obs[&quot;cell_type&quot;]</code>, <code>adata.obs[&quot;celltype&quot;]</code>, <code>adata.obs[&quot;celltypes&quot;]</code>, or <code>adata.obs[&quot;cell_types&quot;]</code>.  Otherwise, returns <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/AnnData.jl#L52-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.subset_adata" href="#scVI.subset_adata"><code>scVI.subset_adata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">subset_adata(adata::AnnData, subset_inds::Tuple, dims::Symbol=:both)</code></pre><p>Subset an <code>AnnData</code> object by indices passed as a tuple of vectors of integers, UnitRanges, or vectors of Booleans. If <code>dims</code> is set to :both, the first element of <code>subset_inds</code> is used to subset cells and the second element is used to subset genes.</p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: <code>AnnData</code> object to subset</li><li><code>subset_inds</code>: tuple of vectors of integers, UnitRanges, or vectors of Booleans</li><li><code>dims</code>: dimension to subset, either <code>:cells</code>, <code>:genes</code>, or <code>:both</code></li></ul><p><strong>Returns</strong></p><ul><li>a copy of the <code>AnnData</code> object with the subsetted data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/AnnData.jl#L103-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.subset_adata-Tuple{AnnData, Union{Int64, Vector{Bool}, Vector{Int64}, UnitRange}, Symbol}" href="#scVI.subset_adata-Tuple{AnnData, Union{Int64, Vector{Bool}, Vector{Int64}, UnitRange}, Symbol}"><code>scVI.subset_adata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subset_adata(adata::AnnData, subset_inds::Union{Int, Vector{Int}, UnitRange, Vector{Bool}}, dims::Symbol)</code></pre><p>Subset an <code>AnnData</code> object by indices passed as a vector of integers or booleans or as a UnitRange.  The <code>dims</code> argument can be set to either <code>:cells</code> or <code>:genes</code> to specify which dimension to subset. </p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: <code>AnnData</code> object to subset</li><li><code>subset_inds</code>: vector of integers or booleans or UnitRange</li><li><code>dims</code>: dimension to subset, either <code>:cells</code> or <code>:genes</code></li></ul><p><strong>Returns</strong></p><ul><li>a copy of the <code>AnnData</code> object with the subsetted data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/AnnData.jl#L123-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.subset_adata!-Tuple{AnnData, Any, Symbol}" href="#scVI.subset_adata!-Tuple{AnnData, Any, Symbol}"><code>scVI.subset_adata!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subset_adata!(adata::AnnData, subset_inds, dims::Symbol)</code></pre><p>In-place version of <code>subset_adata</code>, see <code>?subset_adata</code> for more details. </p><p>For <code>subset_inds</code>, either a tuple of vectors or ranges can be passed with <code>dims</code> set to :both, for subsetting  both cells and genes, or a single vector or range can be passed with <code>dims</code> set to either :cells or :genes.</p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: <code>AnnData</code> object to subset</li><li><code>subset_inds</code>: tuple of vectors of integers, UnitRanges, or vectors of Booleans or vector of integers or booleans or UnitRange</li><li><code>dims</code>: dimension to subset, either <code>:cells</code>, <code>:genes</code>, or <code>:both</code></li></ul><p><strong>Returns</strong></p><ul><li>the <code>AnnData</code> object with the subsetted data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/AnnData.jl#L143-L158">source</a></section></article><h2 id="Library-size-and-normalization"><a class="docs-heading-anchor" href="#Library-size-and-normalization">Library size and normalization</a><a id="Library-size-and-normalization-1"></a><a class="docs-heading-anchor-permalink" href="#Library-size-and-normalization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.init_library_size" href="#scVI.init_library_size"><code>scVI.init_library_size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">init_library_size(adata::AnnData; batch_key::Symbol=:batch)</code></pre><p>Computes and returns library size based on <code>AnnData</code> object. </p><p>Based on the <code>scvi-tools</code> function from <a href="https://github.com/scverse/scvi-tools/blob/04389f74f3e94d7d2986f93eac85cb4543a8608f/scvi/model/_utils.py#L229">here</a> </p><p>Returns a tupe of arrays of length equal to the number of batches in <code>adata</code> as stored in <code>adata.obs[!,:batch_key]</code>,  containing the means and variances of the library size in each batch in <code>adata</code>. Default batch key: <code>:batch</code>, if it is not found, defaults to 1 batch.     </p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: <code>AnnData</code> object</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>batch_key</code>: the key in <code>adata.obs</code> that stores the batch information (default: <code>:batch</code>)</li></ul><p><strong>Returns</strong></p><ul><li>a tuple of arrays of length equal to the number of batches in <code>adata</code> as stored in <code>adata.obs[!,:batch_key]</code>, corresponding to the log library means and vars per batch</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/LibrarySizeNormalization.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.estimate_size_factors" href="#scVI.estimate_size_factors"><code>scVI.estimate_size_factors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">estimate_size_factors(mat; locfunc=median)</code></pre><p>Estimates size factors to use for normalization, based on the corresponding Seurat functionality.  Assumes a countmatrix <code>mat</code> in cell x gene format as input, returns a vector of size factors. </p><p>For details, please see the Seurat documentation. </p><p><strong>Arguments</strong></p><ul><li><code>mat</code>: countmatrix in cell x gene format</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>locfunc</code>: the function to use for calculating the location parameter (default: <code>median</code>)</li></ul><p><strong>Returns</strong></p><ul><li>a vector of size factors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/LibrarySizeNormalization.jl#L52-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.normalize_size_factors" href="#scVI.normalize_size_factors"><code>scVI.normalize_size_factors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize_size_factors(mat::Abstractmatrix)</code></pre><p>Normalizes the countdata in <code>mat</code> by dividing it by the size factors calculated with <code>estimate_size_factors</code>.  Assumes a countmatrix <code>mat</code> in cell x gene format as input, returns the normalized matrix.</p><p><strong>Arguments</strong></p><ul><li><code>mat</code>: countmatrix in cell x gene format</li></ul><p><strong>Returns</strong></p><ul><li>the normalized countmatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/LibrarySizeNormalization.jl#L87-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.normalize_size_factors!" href="#scVI.normalize_size_factors!"><code>scVI.normalize_size_factors!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize_size_factors(adata::AnnData)</code></pre><p>Normalizes the <code>adata.X</code> by dividing it by the size factors calculated with <code>estimate_size_factors</code>.  Adds the normalized count matrix to <code>adata.layers</code> and returns <code>adata</code>.</p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: <code>AnnData</code> object</li></ul><p><strong>Returns</strong></p><ul><li>the modified <code>AnnData</code> object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/LibrarySizeNormalization.jl#L104-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.normalize_total!" href="#scVI.normalize_total!"><code>scVI.normalize_total!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize_total!(adata::AnnData; 
    target_sum::Union{Nothing, Real}=nothing, 
    key_added::String=&quot;cell_counts&quot;,
    layer::Union{Nothing, String}=nothing,
    verbose::Bool=false)</code></pre><p>Normalizes counts per cell, specifically normalize each cell by total counts over all genes, so that every cell has the same total count after normalization. If choosing <code>target_sum=1e6</code>, this is CPM normalization.</p><p>Basic version of the <a href="https://github.com/scverse/scanpy/blob/ed3b277b2f498e3cab04c9416aaddf97eec8c3e2/scanpy/preprocessing/_normalization.py#L45-L241">scanpy.pp.normalize_total function</a></p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: <code>AnnData</code> object </li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>target_sum</code>: if <code>nothing</code>, after normalization, each observation (cell) has a total count equal to the median of total counts for observations (cells) before normalization.</li><li><code>key_added</code>: name of the field in <code>adata.obs</code> where the normalization factor is stored, set to &quot;cell_counts&quot; by default </li><li><code>layer</code>: optional; which layer to normalize on. If <code>nothing</code>, <code>adata.X</code> is used. </li></ul><p><strong>Returns</strong></p><ul><li>the <code>adata</code> object with normalized version of the original <code>adata.X</code> in <code>adata.layers</code> and the size factors in <code>adata.obs</code>. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/LibrarySizeNormalization.jl#L125-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.normalize_total" href="#scVI.normalize_total"><code>scVI.normalize_total</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize_total(adata::AnnData; 
    target_sum::Union{Nothing, Real}=1e4, 
    key_added::String=&quot;cell_counts&quot;,
    verbose::Bool=false)</code></pre><p>Normalizes counts per cell, specifically normalize each cell by total counts over all genes, so that every cell has the same total count after normalization. See <code>normalize_total!</code> for details.  Unlike the in-place version, this function returns a dictionary with the normalized counts and scaled counts per cell. </p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: <code>AnnData</code> object</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>target_sum</code>: if <code>nothing</code>, after normalization, each observation (cell) has a total count equal to the median of total counts for observations (cells) before normalization.</li><li><code>key_added</code>: name of the field in <code>adata.obs</code> where the normalization factor is stored, set to &quot;cell_counts&quot; by default</li><li><code>verbose</code>: whether to print progress messages (default: false)</li></ul><p><strong>Returns</strong></p><ul><li>a dictionary with the normalized counts and scaled counts per cell</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/LibrarySizeNormalization.jl#L166-L186">source</a></section></article><h2 id="Filtering"><a class="docs-heading-anchor" href="#Filtering">Filtering</a><a id="Filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.filter_cells" href="#scVI.filter_cells"><code>scVI.filter_cells</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function filter_cells(countmatrix::AbstractMatrix; 
    min_counts::Union{Int, Nothing}=nothing, 
    min_genes::Union{Int, Nothing}=nothing, 
    max_counts::Union{Int, Nothing}=nothing, 
    max_genes::Union{Int, Nothing}=nothing,
    verbose::Bool=true,
    make_plot::Bool=false,
    log_transform_plot::Bool=false,
    save_plot::Bool=false,
    plot_filename::String=&quot;gene_filtering_histogram.pdf&quot;
    )</code></pre><p>Filter cell outliers based on counts and numbers of genes expressed. For instance, only keep cells with at least <code>min_counts</code> counts or <code>min_genes</code> genes expressed. This is to filter measurement outliers, i.e. “unreliable” observations. Only provide one of the optional parameters <code>min_counts</code>, <code>min_genes</code>, <code>max_counts</code>, <code>max_genes</code> per call.</p><p><strong>Arguments</strong></p><ul><li><code>countmatrix</code>: countmatrix of shape <code>n_obs</code> × <code>n_vars</code>. Rows correspond to cells and columns to genes.</li><li><code>min_counts</code>: Minimum number of counts required for a cell to pass filtering.</li><li><code>min_genes</code>: Minimum number of genes expressed required for a cell to pass filtering.</li><li><code>max_counts</code>: Maximum number of counts required for a cell to pass filtering.</li><li><code>max_genes</code>: Maximum number of genes expressed required for a cell to pass filtering.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>verbose</code>: whether to print info and status messages</li><li><code>make_plot</code>: whether to plot the histogram of cells before filtering</li><li><code>log_transform_plot</code>: whether to log-transform the counts of cells for plotting</li><li><code>save_plot</code>: whether to save the histogram of cells before filtering</li><li><code>plot_filename</code>: filename to save the histogram of cells before filtering</li></ul><p><strong>Returns</strong></p><ul><li><code>cells_subset</code>: BitVector index mask that does filtering; <code>true</code> means that the   cell is kept, <code>false</code> means the cell is removed.</li><li><code>number_per_cell</code>: Depending on what was thresholded (<code>counts</code> or <code>genes</code>),   the array stores <code>n_counts</code> or <code>n_genes</code> per cell.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/Filtering.jl#L117-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.filter_cells!" href="#scVI.filter_cells!"><code>scVI.filter_cells!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function filter_cells!(adata::AnnData; 
    min_counts::Union{Int, Nothing}=nothing, 
    min_genes::Union{Int, Nothing}=nothing, 
    max_counts::Union{Int, Nothing}=nothing, 
    max_genes::Union{Int, Nothing}=nothing,
    verbose::Bool = true, 
    plot_before::Bool=false,
    log_transform_plot::Bool=false,
    plot_after::Bool=false,
    save_plot_before::Bool=false, 
    save_plot_after::Bool=false,
    plot_filename_before::String=&quot;cell_histogram_before_filtering.pdf&quot;,
    plot_filename_after::String=&quot;cell_histogram_after_filtering.pdf&quot;
    )</code></pre><p>Filter cell outliers based on counts and numbers of genes expressed. For instance, only keep cells with at least <code>min_counts</code> counts or <code>min_genes</code> genes expressed. This is to filter measurement outliers, i.e. “unreliable” observations. Only provide one of the optional parameters <code>min_counts</code>, <code>min_genes</code>, <code>max_counts</code>, <code>max_genes</code> per call.</p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: <code>AnnData</code> object of shape <code>n_obs</code> × <code>n_vars</code>. Rows correspond to cells and columns to genes.</li><li><code>min_counts</code>: Minimum number of counts required for a cell to pass filtering.</li><li><code>min_genes</code>: Minimum number of genes expressed required for a cell to pass filtering.</li><li><code>max_counts</code>: Maximum number of counts required for a cell to pass filtering.</li><li><code>max_genes</code>: Maximum number of genes expressed required for a cell to pass filtering</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>verbose</code>: whether to print info and status messages</li><li><code>plot_before</code>: whether to plot the histogram of cells before filtering</li><li><code>log_transform_plot</code>: whether to log-transform the counts of cells for plotting </li><li><code>plot_after</code>: whether to plot the histogram of cells after filtering</li><li><code>save_plot_before</code>: whether to save the histogram of cells before filtering</li><li><code>save_plot_after</code>: whether to save the histogram of cells after filtering</li><li><code>plot_filename_before</code>: filename to save the histogram of cells before filtering</li><li><code>plot_filename_after</code>: filename to save the histogram of cells after filtering</li></ul><p><strong>Returns</strong></p><ul><li>the filtered <code>AnnData</code> object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/Filtering.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.filter_genes!" href="#scVI.filter_genes!"><code>scVI.filter_genes!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">filter_genes!(adata::AnnData; 
    min_counts::Union{Int, Nothing}=nothing, 
    min_cells::Union{Int, Nothing}=nothing, 
    max_counts::Union{Int, Nothing}=nothing, 
    max_cells::Union{Int, Nothing}=nothing,
    verbose::Bool = true,
    plot_before::Bool=false,
    log_transform_plot::Bool=false,
    plot_after::Bool=false,
    save_plot_before::Bool=false, 
    save_plot_after::Bool=false,
    plot_filename_before::String=&quot;gene_histogram_before_filtering.pdf&quot;,
    plot_filename_after::String=&quot;gene_histogram_after_filtering.pdf&quot;
)</code></pre><p>Filter genes based on number of cells or counts. Keep genes that have at least <code>min_counts</code> counts or are expressed in at least <code>min_cells</code> cells or have at most <code>max_counts</code> counts or are expressed in at most <code>max_cells</code> cells. Only provide one of the optional parameters <code>min_counts</code>, <code>min_cells</code>, <code>max_counts</code>, <code>max_cells</code> per call.</p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: <code>AnnData</code> object of shape <code>n_obs</code> × <code>n_vars</code>. Rows correspond</li></ul><p>to cells and columns to genes.</p><ul><li><code>min_counts</code>: Minimum number of counts required for a gene to pass filtering.</li><li><code>min_cells</code>: Minimum number of cells expressed required for a gene to pass filtering.</li><li><code>max_counts</code>: Maximum number of counts required for a gene to pass filtering.</li><li><code>max_cells</code>: Maximum number of cells expressed required for a gene to pass filtering.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>verbose</code>: whether to print info and status messages</li><li><code>plot_before</code>: whether to plot the histogram of genes before filtering</li><li><code>log_transform_plot</code>: whether to log-transform the counts of genes for plotting </li><li><code>plot_after</code>: whether to plot the histogram of genes after filtering</li><li><code>save_plot_before</code>: whether to save the histogram of genes before filtering</li><li><code>save_plot_after</code>: whether to save the histogram of genes after filtering</li><li><code>plot_filename_before</code>: filename to save the histogram of genes before filtering</li><li><code>plot_filename_after</code>: filename to save the histogram of genes after filtering</li></ul><p>Returns</p><ul><li>the filtered <code>AnnData</code> object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/Filtering.jl#L250-L293">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.filter_genes" href="#scVI.filter_genes"><code>scVI.filter_genes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">filter_genes(adata::AnnData; 
    min_counts::Union{Int, Nothing}=nothing, 
    min_cells::Union{Int, Nothing}=nothing, 
    max_counts::Union{Int, Nothing}=nothing, 
    max_cells::Union{Int, Nothing}=nothing,
    verbose::Bool=true,
    make_plot::Bool=false,
    log_transform_plot::Bool=false,
    save_plot::Bool=false,
    plot_filename::String=&quot;gene_filtering_histogram.pdf&quot;
    )</code></pre><p>Filter genes based on number of cells or counts. Keep genes that have at least <code>min_counts</code> counts or are expressed in at least <code>min_cells</code> cells or have at most <code>max_counts</code> counts or are expressed in at most <code>max_cells</code> cells. Only provide one of the optional parameters <code>min_counts</code>, <code>min_cells</code>, <code>max_counts</code>, <code>max_cells</code> per call. This is the out-of-place version; for details on the input arguments, see the in-place version <code>filter_genes!</code></p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: <code>AnnData</code> object of shape <code>n_obs</code> × <code>n_vars</code>. Rows correspond to cells and columns to genes.</li><li><code>min_counts</code>: Minimum number of counts required for a gene to pass filtering.</li><li><code>min_cells</code>: Minimum number of cells in which it is expressed required for a gene to pass filtering.</li><li><code>max_counts</code>: Maximum number of counts required for a gene to pass filtering.</li><li><code>max_cells</code>: Maximum number of cells in which it is expressed required for a gene to pass filtering.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>verbose</code>: whether to print info and status messages</li><li><code>make_plot</code>: whether to plot the histogram of cells before filtering</li><li><code>log_transform_plot</code>: whether to log-transform the counts of cells for plotting</li><li><code>save_plot</code>: whether to save the histogram of cells before filtering</li><li><code>plot_filename</code>: filename to save the histogram of cells before filtering</li></ul><p><strong>Returns</strong></p><ul><li><code>gene_subset</code>: BitVector index mask that does filtering; <code>true</code> means that the   gene is kept, <code>false</code> means the cell is removed.</li><li><code>number_per_gene</code>: Depending on what was thresholded (<code>counts</code> or <code>cells</code>),   the array stores <code>n_counts</code> or <code>n_cells</code> per gene.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/Filtering.jl#L366-L406">source</a></section></article><h2 id="Simple-transformations"><a class="docs-heading-anchor" href="#Simple-transformations">Simple transformations</a><a id="Simple-transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-transformations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.log_transform!" href="#scVI.log_transform!"><code>scVI.log_transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">log_transform!(adata::AnnData; 
    layer::String=&quot;normalized&quot;,
    verbose::Bool=false)</code></pre><p>Log-transforms the data. Looks for a layer of normalized counts in <code>adata.layers[&quot;normalized&quot;]</code>.  If the layer is not there, it uses <code>adata.X</code>. </p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: the <code>AnnData</code> object to be modified</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>layer</code>: the layer to be used for PCA (default: &quot;log_transformed&quot;)</li><li><code>verbose</code>: whether to print progress messages (default: false)</li></ul><p><strong>Returns</strong></p><ul><li>the adata object with the log-transformed values in a new layer <code>&quot;log_transformed&quot;</code>. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/Transformations.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.logp1_transform!" href="#scVI.logp1_transform!"><code>scVI.logp1_transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logp1_transform!(adata::AnnData; 
    layer::Union{String, Nothing}=nothing,
    verbose::Bool=false)</code></pre><p>Log-transforms the (count) data, adding a pseudocount of 1.  Uses the X in <code>adata.X</code> by default, but other layers can be passed using the <code>layer</code> keyword. </p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: the <code>AnnData</code> object to be modified</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>layer</code>: the layer to be used for log + 1 transformation</li><li><code>verbose</code>: whether to print progress messages (default: false)</li></ul><p><strong>Returns</strong></p><ul><li>the adata object with the log-transformed values in a new layer <code>&quot;logp1_transformed&quot;</code>. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/Transformations.jl#L36-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.sqrt_transform!" href="#scVI.sqrt_transform!"><code>scVI.sqrt_transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sqrt_transform!(adata::AnnData; 
    layer::String=&quot;normalized&quot;,
    verbose::Bool=false)</code></pre><p>Sqrt-transforms the data. Looks for a layer of normalized counts in <code>adata.layers[&quot;normalized&quot;]</code>.  If the layer is not there, it uses <code>adata.X</code>. </p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: the <code>AnnData</code> object to be modified</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>layer</code>: the layer to be used for the transformation</li><li><code>verbose</code>: whether to print progress messages (default: false)</li></ul><p><strong>Returns</strong></p><ul><li>the adata object with the sqrt-transformed values in a new layer <code>&quot;sqrt_transformed&quot;</code>. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/Transformations.jl#L72-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.rescale!" href="#scVI.rescale!"><code>scVI.rescale!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rescale!(adata::AnnData; 
    layer::Union{String, Nothing}=nothing,
    verbose::Bool=false)</code></pre><p>Rescales the data to zero mean and unit variance in each gene, using the specified layer. If none is provided, it uses <code>adata.X</code>. </p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: the <code>AnnData</code> object to be modified</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>layer</code>: the layer to be used for the transformation</li><li><code>verbose</code>: whether to print progress messages (default: false)</li></ul><p><strong>Returns</strong></p><ul><li>the adata object with the rescales values in a new layer <code>&quot;rescaled&quot;</code>. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/Transformations.jl#L106-L122">source</a></section></article><h2 id="Dimension-reduction"><a class="docs-heading-anchor" href="#Dimension-reduction">Dimension reduction</a><a id="Dimension-reduction-1"></a><a class="docs-heading-anchor-permalink" href="#Dimension-reduction" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.pca!" href="#scVI.pca!"><code>scVI.pca!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function pca!(adata::AnnData; 
    layer::String=&quot;log_transformed&quot;, 
    n_pcs::Int=size(adata.X,2),
    verbose::Bool=false
)</code></pre><p>Performs a PCA on the specified layer of an <code>AnnData</code> object and stores the results in <code>adata.obsm</code>.  Uses all variables of the layer by default, but the number of PCs to be stored can also be specified with the <code>n_pcs</code> keyword.  If the layer is not found, the log-transformed normalized counts are calculated and used.</p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: the <code>AnnData</code> object to be modified</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>layer</code>: the layer to be used for PCA (default: &quot;log_transformed&quot;)</li><li><code>n_pcs</code>: the number of PCs to be stored (default: all variables)</li><li><code>verbose</code>: whether to print progress messages (default: false)</li></ul><p><strong>Returns</strong></p><ul><li>the modified <code>AnnData</code> object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/DimensionReduction.jl#L15-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.umap!" href="#scVI.umap!"><code>scVI.umap!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function umap!(adata::AnnData; 
    layer::String=&quot;log_transformed&quot;, 
    use_pca_init::Bool=false, 
    n_pcs::Int=100, 
    verbose::Bool=true, 
    kwargs...)</code></pre><p>Performs UMAP on the specified layer of an <code>AnnData</code> object.  If the layer is not found, the log-transformed normalized counts are calculated and used.  Optionally, UMAP can be run on a PCA representation, the number of PCs can be specified (default=100).  For customizing the behaviour or UMAP, see the keyword arguments of the <code>UMAP.UMAP_</code> function.  They can all be passed via the <code>kwargs</code>. </p><p>The fields of the resulting <code>UMAP_</code> struct are stored as follows:      - the UMAP embedding in <code>adata.obsm[&quot;umap&quot;]</code>,      - the fuzzy simplicial knn graph in adata.obsp[&quot;fuzzy<em>neighbor</em>graph&quot;],      - the KNNs of each cell in <code>adata.obsm[&quot;knns&quot;]</code>,      - the distances of each cell to its KNNs in <code>adata.obsm[&quot;knn_dists&quot;]</code></p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: the <code>AnnData</code> object to be modified</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>layer</code>: the layer to be used for UMAP (default: &quot;log_transformed&quot;)</li><li><code>use_pca_init</code>: whether to use a PCA representation for UMAP (default: false)</li><li><code>n_pcs</code>: the number of PCs to be used for UMAP (default: 100)</li><li><code>verbose</code>: whether to print progress messages (default: false)</li><li><code>kwargs</code>: keyword arguments for <code>UMAP.UMAP_</code></li></ul><p><strong>Returns</strong></p><ul><li>the modified <code>AnnData</code> object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/DimensionReduction.jl#L73-L105">source</a></section></article><h2 id="Highly-variable-genes"><a class="docs-heading-anchor" href="#Highly-variable-genes">Highly variable genes</a><a id="Highly-variable-genes-1"></a><a class="docs-heading-anchor-permalink" href="#Highly-variable-genes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.highly_variable_genes-Tuple{AnnData}" href="#scVI.highly_variable_genes-Tuple{AnnData}"><code>scVI.highly_variable_genes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">highly_variable_genes(adata::AnnData;
    layer::Union{String,Nothing} = nothing,
    n_top_genes::Int=2000,
    batch_key::Union{String,Nothing} = nothing,
    span::Float64=0.3
    )</code></pre><p>Computes highly variable genes according to the workflows on <code>scanpy</code> and Seurat v3 per batch and returns a dictionary with  the information on the joint HVGs. For the in-place version, see <code>highly_variable_genes!</code></p><p>More specifically, it is the Julia re-implementation of the corresponding  <a href="https://github.com/scverse/scanpy/blob/master/scanpy/preprocessing/_highly_variable_genes.py"><code>scanpy</code> function</a> For implementation details, please check the <code>scanpy</code>/Seurat documentations or the source code of the  lower-level <code>_highly_variable_genes_seurat_v3</code> function in this package.  Results are almost identical to the <code>scanpy</code> function. The differences have been traced back to differences in  the local regression for the mean-variance relationship implemented in the Loess.jl package, that differs slightly  from the corresponding Python implementation. </p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: <code>AnnData</code> object </li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>layer</code>: optional; which layer to use for calculating the HVGs. Function assumes this is a layer of counts. If <code>layer</code> is not provided, <code>adata.X</code> is used. </li><li><code>n_top_genes</code>: optional; desired number of highly variable genes. Default: 2000. </li><li><code>batch_key</code>: optional; key where to look for the batch indices in <code>adata.obs</code>. If not provided, data is treated as one batch. </li><li><code>span</code>: span to use in the loess fit for the mean-variance local regression. See the Loess.jl docs for details. </li><li><code>replace_hvgs</code>: whether or not to replace the hvg information if there are already hvgs calculated. If false, the new values are added with a &quot;_1&quot; suffix. Default:true,</li><li><code>verbose</code>: whether or not to print info on current status</li></ul><p><strong>Returns</strong></p><ul><li>a dictionary containing information on the highly variable genes, specifically containing the following keys is added: <ul><li><code>highly_variable</code>: vector of <code>Bool</code>s indicating which genes are highly variable</li><li><code>highly_variable_rank</code>: rank of the highly variable genes according to (corrected) variance </li><li><code>means</code>: vector with means of each gene</li><li><code>variances</code>: vector with variances of each gene </li><li><code>variances_norm</code>: normalized variances of each gene </li><li><code>highly_variable_nbatches</code>: if there are batches in the dataset, logs the number of batches in which each highly variable gene was actually detected as highly variable. </li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/HighlyVariableGenes.jl#L148-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.highly_variable_genes!-Tuple{AnnData}" href="#scVI.highly_variable_genes!-Tuple{AnnData}"><code>scVI.highly_variable_genes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">highly_variable_genes!(adata::AnnData;
    layer::Union{String,Nothing} = nothing,
    n_top_genes::Int=2000,
    batch_key::Union{String,Nothing} = nothing,
    span::Float64=0.3,
    replace_hvgs::Bool=true,
    verbose::Bool=false
    )</code></pre><p>Computes highly variable genes per batch according to the workflows on <code>scanpy</code> and Seurat v3 in-place.  This is the in-place version that adds an dictionary containing information on the highly variable genes directly  to the <code>adata.var</code> and returns the modified <code>AnnData</code> object.  For details, see the not-in-place version <code>?highly_variable_genes</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/HighlyVariableGenes.jl#L114-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.subset_to_hvg!-Tuple{AnnData}" href="#scVI.subset_to_hvg!-Tuple{AnnData}"><code>scVI.subset_to_hvg!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subset_to_hvg!(adata::AnnData;
    layer::Union{String,Nothing} = nothing,
    n_top_genes::Int=2000,
    batch_key::Union{String,Nothing} = nothing,
    span::Float64=0.3,
    verbose::Bool=true
)</code></pre><p>Calculates highly variable genes with <code>highly_variable_genes!</code> and subsets the <code>AnnData</code> object to the calculated HVGs.  For description of input arguments, see <code>highly_variable_genes!</code></p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: <code>AnnData</code> object</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>layer</code>: optional; which layer to use for calculating the HVGs. Function assumes this is a layer of counts. If <code>layer</code> is not provided, <code>adata.X</code> is used.</li><li><code>n_top_genes</code>: optional; desired number of highly variable genes. Default: 2000.</li><li><code>batch_key</code>: optional; key where to look for the batch indices in <code>adata.obs</code>. If not provided, data is treated as one batch.</li><li><code>span</code>: span to use in the loess fit for the mean-variance local regression. See the Loess.jl docs for details.</li><li><code>verbose</code>: whether or not to print info on current status</li></ul><p><strong>Returns</strong></p><ul><li><code>adata</code> object subset to the calculated HVGs, both in the countmatrix/layer data used for HVG calculation and in the <code>adata.var</code> dictionary.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/HighlyVariableGenes.jl#L206-L230">source</a></section></article><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.plot_pca" href="#scVI.plot_pca"><code>scVI.plot_pca</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function plot_pca(
    adata::AnnData;
    color_by::String=&quot;&quot;,
    pcs::Vector{Int}=[1,2],
    recompute::Bool=false,
    save_plot::Bool=false,
    filename::String=&quot;PCA.pdf&quot;
)</code></pre><p>Plot a PCA embedding on a given <code>AnnData</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: AnnData object</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>color_by</code>: column name of <code>adata.obs</code> to color the plot by, or a gene name to color by expression.    If neither is provided, celltypes will be used if present, otherwise all cells will be colored the same.</li><li><code>pcs</code>: which PCs to plot</li><li><code>recompute</code>: whether to recompute the PCA embedding or use an already existing one</li><li><code>save_plot</code>: whether to save the plot to a file</li><li><code>filename</code>: filename to save the plot to</li></ul><p><strong>Returns</strong></p><ul><li>the plot object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/Plotting.jl#L229-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.plot_umap" href="#scVI.plot_umap"><code>scVI.plot_umap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function plot_umap(
    adata::AnnData;
    color_by::String=&quot;&quot;,
    recompute::Bool=false,
    save_plot::Bool=false,
    filename::String=&quot;UMAP.pdf&quot;
    )</code></pre><p>Plot a UMAP embedding on a given <code>AnnData</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: AnnData object</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>color_by</code>: column name of <code>adata.obs</code> to color the plot by, or a gene name to color by expression.    If neither is provided, celltypes will be used if present, otherwise all cells will be colored the same.</li><li><code>recompute</code>: whether to recompute the UMAP embedding  </li><li><code>save_plot</code>: whether to save the plot to a file</li><li><code>filename</code>: filename to save the plot to</li></ul><p><strong>Returns</strong></p><ul><li>the plot object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/Plotting.jl#L293-L316">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.plot_histogram" href="#scVI.plot_histogram"><code>scVI.plot_histogram</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function plot_histogram(adata::AnnData, 
    cell_gene::Symbol = :gene, 
    counts_number::Symbol = :counts; 
    cutoff::Union{Nothing, Real}=nothing,
    log_transform::Bool=false, 
    save_plot::Bool=false, 
    filename::String=&quot;counts_per_gene_histogram.pdf&quot;
    )</code></pre><p>Plot a histogram of counts per gene or cells,  or alternatively he number of genes expressed per cell or  the number of cells per gene in which it is expressed.</p><p>Additionally, a user-specified cutoff can be plotted on top,  to be used as a visualization tool for filtering.</p><p>The function is called internally when using the plotting options  in the <code>filter_cells</code> and <code>filter_genes</code> functions.</p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: AnnData object</li><li><code>cell_gene</code>: one of <code>:cell</code> or <code>gene</code>; whether to plot counts per gene or per cell</li><li><code>counts_number</code>: one of <code>:counts</code> or <code>:number</code>; whether to plot counts or number of genes/cells</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>cutoff</code>: cutoff to plot on top of the histogram</li><li><code>log_transform</code>: whether to log transform the counts</li><li><code>save_plot</code>: whether to save the plot to a file</li><li><code>filename</code>: filename to save the plot to</li></ul><p><strong>Returns</strong></p><ul><li><code>hist</code>: the plot object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/Plotting.jl#L4-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.plot_highest_expressed_genes" href="#scVI.plot_highest_expressed_genes"><code>scVI.plot_highest_expressed_genes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot_highest_expressed_genes(adata::AnnData; 
    n_top::Int=30, 
    gene_symbols::Union{String, Nothing}=nothing,
    save_plot::Bool=false,
    filename::String=&quot;highest_expressed_genes.pdf&quot;
)</code></pre><p>The function computes for each gene the fraction of counts assigned to that gene within a cell.  The <code>n_top</code> genes with the highest mean fraction over all cells are plotted as boxplots.</p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: AnnData object</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>n_top</code>: number of genes to plot</li><li><code>gene_symbols</code>: column name of <code>adata.var</code> to use as gene names. If <code>nothing</code>, <code>adata.var_names</code> will be used.</li><li><code>save_plot</code>: whether to save the plot to a file</li><li><code>filename</code>: filename to save the plot to</li></ul><p><strong>Returns</strong></p><ul><li>the plot object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/Plotting.jl#L101-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.plot_highly_variable_genes" href="#scVI.plot_highly_variable_genes"><code>scVI.plot_highly_variable_genes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function plot_highly_variable_genes(adata::AnnData;
    log_transform::Bool=false,
    save_plot::Bool=false,
    filename::String=&quot;highly_variable_genes.pdf&quot;
    )
end</code></pre><p>Plot dispersions or normalized variance versus means for genes</p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: AnnData object</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>log_transform</code>: whether to log transform the counts</li><li><code>save_plot</code>: whether to save the plot to a file</li><li><code>filename</code>: filename to save the plot to</li></ul><p><strong>Returns</strong></p><ul><li>the plot object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/Plotting.jl#L162-L182">source</a></section></article><h2 id="Loading-built-in-datasets"><a class="docs-heading-anchor" href="#Loading-built-in-datasets">Loading built-in datasets</a><a id="Loading-built-in-datasets-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-built-in-datasets" title="Permalink"></a></h2><p>There are currently three datasets for which the package supplies built-in convenience functions for loading, processing and creating corresponding <code>AnnData</code> objects. They can be downloaded from this <a href="https://drive.google.com/drive/folders/1JYNypxWnQhigEJ37jOiEwv7fzGW71jC8?usp=sharing">Google Drive <code>data</code> folder</a>. The folder contains all three datasets, namely </p><ul><li>the <code>cortex</code> data, corresponding to the <a href="https://github.com/scverse/scvi-tools/blob/master/scvi/data/_built_in_data/_cortex.py"><code>cortex</code> dataset from the <code>scvi-tools</code></a> from <a href="https://www.science.org/doi/10.1126/science.aaa1934">Zeisel et al. 2015</a>. The original data can be found <a href="https://storage.googleapis.com/linnarsson-lab-www-blobs/blobs/cortex/expression_mRNA_17-Aug-2014.txt">here</a> and has been processed analogous to the <a href="https://github.com/scverse/scvi-tools/blob/master/scvi/data/_built_in_data/_cortex.py"><code>scvi-tools</code> processing</a></li><li>the <code>tasic</code> data from <a href="https://www.nature.com/articles/nn.4216">Tasic et al. (2016)</a>, available at <a href="https://www.ncbi.nlm.nih.gov/geo/">Gene expression Omnibus (GEO)</a> under accession number GSE71585. Preprocessing and additional annotation according to the original manuscript; annotations are available and loaded together with the countmatrix. </li><li>the <code>pbmc</code> data (PBMC8k) from <a href="https://www.nature.com/articles/ncomms14049">Zheng et al. 2017</a>, preprocessed according to the <a href="https://bioconductor.org/books/3.15/OSCA.workflows/unfiltered-human-pbmcs-10x-genomics.html">Bioconductor workflow</a>.</li></ul><p>I recommend downloading the complete GoogleDrive folder and having it as a subfolder named <code>data</code> in the current working directory. Then, in any Julia script in the parent directory, the functions <code>load_cortex()</code>, <code>load_pbmc()</code> and <code>load_tasic()</code> can be called without arguments, because the default <code>path</code> where these functions look for the respective dataset is exactly that subfolder named <code>data</code>.  </p><h3 id="Cortex-data"><a class="docs-heading-anchor" href="#Cortex-data">Cortex data</a><a id="Cortex-data-1"></a><a class="docs-heading-anchor-permalink" href="#Cortex-data" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.load_cortex" href="#scVI.load_cortex"><code>scVI.load_cortex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_cortex(path::String=&quot;&quot;; verbose::Bool=false)</code></pre><p>Loads <code>cortex</code> dataset from <a href="https://www.science.org/doi/10.1126/science.aaa1934">Zeisel et al. 2015</a> and creates a corresponding <code>AnnData</code> object. </p><p>Looks for a file <code>cortex_anndata.h5ad</code> that can be downloaded from <a href="https://drive.google.com/drive/folders/1JYNypxWnQhigEJ37jOiEwv7fzGW71jC8?usp=sharing">this GoogleDrive <code>data</code> folder</a>.  The functions first looks in the folder passed as <code>path</code> (default: assumes files are in a subfolder named <code>data</code> of the current directory, i.e., that the complete GoogleDrive <code>data</code> folder has been downloaded in the current directory), and alternatively downloads the data if is cannot find the file in the given <code>path</code> (see below).</p><p>The file is the <code>h5</code> export of the Python <code>AnnData</code> object provided as <a href="https://github.com/scverse/scvi-tools/blob/master/scvi/data/_built_in_data/_cortex.py">built-in <code>cortex</code> dataset from <code>scvi-tools</code></a>,  data is from <a href="https://www.science.org/doi/10.1126/science.aaa1934">Zeisel et al. 2015</a>.</p><p>If the file is present, the data is loaded from the Python <code>AnnData</code> object and stored in an analogous Julia <code>AnnData</code> object.  This is handled by the functions <code>init_cortex_from_h5ad</code> and <code>load_cortex_from_h5ad</code>. </p><p>Alternatively, if the <code>h5ad</code> file is not found in the folder, the data is downloaded directly  <a href="https://storage.googleapis.com/linnarsson-lab-www-blobs/blobs/cortex/expression_mRNA_17-Aug-2014.txt">from the original authors</a> and  processed analogous to the <a href="https://github.com/scverse/scvi-tools/blob/master/scvi/data/_built_in_data/_cortex.py"><code>scvi-tools</code> processing</a>,  and subsequently stored to a Julia <code>AnnData</code> object. This is handled by the function <code>init_cortex_from_url</code>. </p><p><strong>Arguments</strong></p><ul><li><code>path::String</code>: path to the folder where the file is stored</li><li><code>verbose::Bool</code>: whether to print progress information</li></ul><p><strong>Returns</strong></p><ul><li>the Julia <code>AnnData</code> object.</li></ul><p><strong><strong>Example</strong></strong></p><pre><code class="nohighlight hljs">julia&gt; load_cortex()
    AnnData object with a countmatrix with 3005 cells and 1200 genes
    layers dict with the following keys: [&quot;counts&quot;]
    summary statistics dict with the following keys: [&quot;n_labels&quot;, &quot;n_vars&quot;, &quot;n_batch&quot;, &quot;n_continuous_covs&quot;, &quot;n_cells&quot;, &quot;n_proteins&quot;]
    unique celltypes: [&quot;interneurons&quot;, &quot;pyramidal SS&quot;, &quot;pyramidal CA1&quot;, &quot;oligodendrocytes&quot;, &quot;microglia&quot;, &quot;endothelial-mural&quot;, &quot;astrocytes_ependymal&quot;]
    training status: not trained</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/Cortex.jl#L78-L113">source</a></section></article><h3 id="PBMC-data"><a class="docs-heading-anchor" href="#PBMC-data">PBMC data</a><a id="PBMC-data-1"></a><a class="docs-heading-anchor-permalink" href="#PBMC-data" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.load_pbmc" href="#scVI.load_pbmc"><code>scVI.load_pbmc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_pbmc(path::String = &quot;data/&quot;)</code></pre><p>Loads <code>pbmc</code> dataset from <a href="https://www.nature.com/articles/ncomms14049">Zheng et al. 2017</a> and creates a corresponding <code>AnnData</code> object.  Specifically, the PBMC8k version is used, preprocessed according to the <a href="https://bioconductor.org/books/3.15/OSCA.workflows/unfiltered-human-pbmcs-10x-genomics.html">Bioconductor workflow</a>.</p><p>Loads the following files that can be downloaded from <a href="https://drive.google.com/drive/folders/1JYNypxWnQhigEJ37jOiEwv7fzGW71jC8?usp=sharing">this GoogleDrive <code>data</code> folder</a>: </p><ul><li><code>PBMC_counts.csv</code>: countmatrix  </li><li><code>PBMC_annotation.csv</code>: cell type annotation</li></ul><p>Files are loaded from the folder passed as <code>path</code> (default: assumes files are in a subfolder named <code>data</code> of the current directory, i.e., that the complete GoogleDrive <code>data</code> folder has been downloaded in the current directory.)</p><p>From these input files, a Julia <code>AnnData</code> object is created. The countmatrix contains information on  cell barcodes and gene names. The gene name and celltype information is stored in the <code>vars</code> and <code>obs</code>  dictionaries of the <code>AnnData</code> object, respectively. </p><p><strong>Arguments</strong></p><ul><li><code>path</code>: path to the folder containing the input files (default: &quot;data/&quot;)</li></ul><p><strong>Returns</strong></p><ul><li>the Julia <code>AnnData</code> object.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; load_pbmc()
    AnnData object with a countmatrix with 7480 cells and 200 genes
    unique celltypes: [&quot;B-cells&quot;, &quot;CD4+ T-cells&quot;, &quot;Monocytes&quot;, &quot;CD8+ T-cells&quot;, &quot;NK cells&quot;, &quot;NA&quot;, &quot;HSC&quot;, &quot;Erythrocytes&quot;]
    training status: not trained</code></pre><p><strong></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/PBMC.jl#L4-L33">source</a></section></article><h3 id="Tasic-data"><a class="docs-heading-anchor" href="#Tasic-data">Tasic data</a><a id="Tasic-data-1"></a><a class="docs-heading-anchor-permalink" href="#Tasic-data" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.load_tasic" href="#scVI.load_tasic"><code>scVI.load_tasic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_tasic(path::String = &quot;data/&quot;)</code></pre><p>Loads <code>tasic</code> dataset based on <a href="https://www.nature.com/articles/nn.4216">Tasic et al. (2016)</a> and creates a corresponding <code>AnnData</code> object. </p><p>Loads the following files that can be downloaded from <a href="https://drive.google.com/drive/folders/1JYNypxWnQhigEJ37jOiEwv7fzGW71jC8?usp=sharing">this GoogleDrive <code>data</code> folder</a>: </p><ul><li><code>Tasic_countmat.txt</code>: countmatrix  </li><li><code>Tasic_celltypes.txt</code>: cell types</li><li><code>Tasic_genenames.txt</code>: gene names </li><li><code>Tasic_receptorandmarkers.txt</code>: List of receptor and marker genes </li></ul><p>Files are loaded from the folder passed as <code>path</code> (default: assumes files are in a subfolder named <code>data</code> of the current directory, i.e., that the complete GoogleDrive <code>data</code> folder has been downloaded in the current directory.</p><p>The original data is available at <a href="https://www.ncbi.nlm.nih.gov/geo/">Gene expression Omnibus (GEO)</a> under accession number GSE71585.  Preprocessing and annotation has been prepared according to the original manuscript. </p><p>From these input files, a Julia <code>AnnData</code> object is created. The list of receptor and marker genes is used  to annotate cells as neural vs. non-neural, and annotate the neural cells as  GABA- or Glutamatergic. </p><p>These annotations together with the cell type information and the gene names and receptor/marker list are stored in Dictionaries  in the <code>obs</code> and <code>vars</code> fields of the <code>AnnData</code> object. </p><p>Additionally, size factors are calculated and used for normalizing the counts.  The normalized counts are stored in an additional <code>layer</code> named <code>normalized_counts</code>.</p><p><strong>Arguments</strong></p><ul><li><code>path</code>: path to the folder containing the input files (default: &quot;data/&quot;)</li></ul><p><strong>Returns</strong></p><ul><li>the Julia <code>AnnData</code> object.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; load_tasic()
    AnnData object with a countmatrix with 1679 cells and 15119 genes
    layers dict with the following keys: [&quot;normalized_counts&quot;, &quot;counts&quot;]
    unique celltypes: [&quot;Vip&quot;, &quot;L4&quot;, &quot;L2/3&quot;, &quot;L2&quot;, &quot;Pvalb&quot;, &quot;Ndnf&quot;, &quot;L5a&quot;, &quot;SMC&quot;, &quot;Astro&quot;, &quot;L5&quot;, &quot;Micro&quot;, &quot;Endo&quot;, &quot;Sst&quot;, &quot;L6b&quot;, &quot;Sncg&quot;, &quot;Igtp&quot;, &quot;Oligo&quot;, &quot;Smad3&quot;, &quot;OPC&quot;, &quot;L5b&quot;, &quot;L6a&quot;]
    training status: not trained</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/Tasic.jl#L5-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scVI.subset_tasic!" href="#scVI.subset_tasic!"><code>scVI.subset_tasic!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">subset_tasic!(adata::AnnData)</code></pre><p>Subsets an input <code>AnnData</code> object initialized from the Tasic data according <code>load_tasic</code> to the neural cells  and the receptor and marker genes provided as annotation. </p><p>Specifically, the count matrix and the normalized count matrix are subset to these cells and genes,  and the dictionaries with information about cells and genes in <code>adata.obs</code> and <code>adata.vars</code> are also subset accordingly. </p><p><strong>Arguments</strong></p><ul><li><code>adata</code>: <code>AnnData</code> object initialized from the Tasic data</li></ul><p><strong>Returns</strong></p><ul><li>the modified <code>AnnData</code> object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maren-ha/scVI.jl/blob/32be9dc5051cefc6c0d6a2ae0107d237b174ef97/src/data/Tasic.jl#L111-L125">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Getting started</a><a class="docs-footer-nextpage" href="scVAE.html">The scVAE model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.0 on <span class="colophon-date" title="Sunday 8 October 2023 20:32">Sunday 8 October 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
